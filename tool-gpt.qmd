
```{r}
#| include: false

source("_common.R")
```


# 챗GPT {#r-automation}


```{webr-r}
#| label: r-plot-hist

hist(rnorm(100))
```



```{pyodide-python}
#| label: py-plot-matplotlib
import numpy as np
import matplotlib.pyplot as plt

# Generate 100 random numbers from a normal distribution
data = np.random.normal(size=100)

# Plot a histogram
plt.hist(data, bins='auto')  # 'bins' can be adjusted for more or less detail
plt.title('Histogram of Randomly Generated Numbers')
plt.show()
```

```{webr-r}
#| label: ggplot-plot-hist
library(ggplot2)

# Generate 100 random numbers from a normal distribution
data <- data.frame(numbers = rnorm(100))

# Create a histogram
ggplot(data, aes(x = numbers)) +
  geom_histogram(bins = 30, fill = "blue", color = "black") +
  ggtitle("Histogram of Randomly Generated Numbers")
```

# 자연어 SQL 쿼리

1950년대부터 본격적으로 컴퓨터가 도입되면서 CLI를 필두로 
다양한 사용자 인터페이스(User Interface)가 적용되었다.
스티브 잡스의 애플사는 매킨토시 GUI에 이어 아이폰 모바일 인터페이스를 
일반화시켰다면, 최근 챗GPT는 언어 사용자 인터페이스(LUI)를 통해
각 분야에 혁신을 예고하고 있다. 챗GPT[@vaswani2017attention] 데이터 과학도 사용자 관점에서 보자. 
기존 R, 파이썬, SQL, 엑셀 등 데이터 과학 구문을 머리속에 암기하고 있거나 구글이나 
네이버를 통해 중요 키워드를 통해 문제를 해결해야 했었다. 하지만, 이제 챗GPT가 자연어를 이해하기 때문에 데이터 전처리, 통계 작업, 데이터 분석, 시각화, 모형개발 등 데이터 과학 전반에 변화는 필연적이다.\index{User Inferface!CLI}\index{User Inferface!GUI}\index{User Inferface!WUI}\index{User Inferface!MUI}
\index{User Inferface!LUI}\index{사용자 인터페이스} [@wickham2023r; @wickham2019welcome; @gozalo2023chatgpt]

```{mermaid}
%%| label: fig-ui-evolution
%%| fig-cap: 사용자 인터페이스 진화

flowchart TB
    
    subgraph A["사용자 인터페이스"]
    direction LR
        CLI["CLI 1950~<br>Command Line Interface<br> GUI 1970~<br> Graphic User Inferface"]     --> WIMI
        WIMI["Web Interface <br> 1994~ <br> Mobile Interface <br> 2007~"] --> NUI["LUI 2023~<br> Language <br> User Interface"]
    end

classDef default fill:#f9f7f7,stroke:#333,stroke-width:2px;
classDef A font-size:16px;

```


챗GPT[@wu2023brief]는 인터넷에서 방대한 양의 데이터를 학습하여 이를 정말 잘 압축한 하나의 저장소로 이해할 수 있다. 따라서, 압축을 풀게 되면 정확히 원본을 복원할 수 있는 부분도 있지만, 그렇지 못한 부분도 당영히 있게 된다.

챗GPT를 “웹의 흐릿한 JPEG”[@chiang2023chatgpt]으로 비유하고 있다. JPEC 기술 자체는 손실 압축기술로 무손실 압축기술로 대표적인 PNG와 대비된다. 흐릿한 이미지가 선명하지 않거나 정확하지 않은 것처럼 ChatGPT도 항상 완벽한 답변을 제공하거나 모든 질문을 제대로 이해하는 것도 아니다. 하지만 사용자와의 대화를 기반으로 끊임없이 학습하고 개선하고 있다. 더 많은 사람들이 챗GPT를 사용할수록 사람의 언어를 더 잘 이해하고 반응할 수 있게 개발된 기술이다.

## 코딩 패러다임

코딩 세계는 끊임없이 진화한다. 전통적인 코딩 방식에서 시작하여 기계학습 코딩, 최근 챗GPT와 같은 대규모 언어모델(LLM)을 활용한 프롬프트 기반 코딩에 이르기까지, 새로운 패러다임이 계속해서 등장하고 있다. 

전통적인 코딩은 프로그래머가 직접 모든 코드를 작성하고 논리를 구축하는 방식으로 개발자 전문성과 경험에 크게 의존하며, 코드 품질과 효율성은 프로그래머의 역량에 달렸다. 하지만 이러한 접근법은 시간이 많이 소요되고 반복적인 작업이 많아 생산성이 낮아 통합개발환경(IDE), 소프트웨어 공학, 소프트웨어 아키텍처, 디자인 패턴 등의 방법론과 도구가 발전하며 개선되어 왔고 현재 주류를 형성하고 있다.

기계학습 코딩은 데이터와 알고리즘을 활용하여 컴퓨터 스스로 코드를 생성하고 최적화할 수 있게 하는 방식으로 전통적인 코딩 방식으로 풀 수 없는 복잡한 문제를 해결할 수 있다.
기계학습 코딩 방식은 대규모 데이터셋과 복잡한 알고리즘을 필요로 하지만, 일단 학습이 완료되면 개발자가 작성한 코드보다 월등한 성능을 보인다. 다만 기계학습 모형의 성능은 데이터의 질과 양, 알고리즘의 복잡성, 컴퓨팅 자원에 따라 크게 좌우된다.

최근 챗GPT와 같은 대규모 언어모델을 활용한 프롬프트 기반 코딩이 주목받고 있다. 자연어 프롬프트를 입력하면 언어모델이 이해하고 관련 코드를 생성한다는 점에서 일종의 생성형 모형으로 볼 수 있다.
프롬프트 기반 코딩은 전통적인 코딩 방식과 기계학습 코딩의 장점을 결합했다. 프로그래머는 자연어로 의도를 표현할 수 있고, LLM은 의도를 파악하여 코드로 변환해주어 생산성과 효율성을 높일 수 있어 매우 유용하다.

![코딩 패러다임 변화](images/coding_paradigms.jpg){#fig-coding-paradigms}


## 프롬프트 공학

**프롬프트 공학(Prompt Engineering)**은 챗GPT와 같은 AI 언어 모형로부터 구체적이고 정확하며 관련성 있는 응답을 도출하기 위해 프롬프트(Prompt, 지시명령어)를 설계하고 개선하는 과정이다. 프롬프트의 품질이 GPT 모형 출력결과에 큰 영향을 미칠 수 있기 때문에 이 작업은 매우 중요하다. 프롬프트 엔지니어링의 목표는 사용자와 AI 모델 사이 커뮤니케이션을 최적화하여 AI 시스템의 유용성과 효율성을 향상시키는 것이다.
\index{프롬프트 공학}

프롬프트 엔지니어링은 반복적인 작업과정으로 AI의 응답에 따라 프롬프트를 조정하고 개선해야 할 수도 있다는 점을 항상 염두에 두고, 다음 프롬프트 구성요소를 프롬프트에 녹여 제작할 경우 AI 언어 모델이 목표에 부합하는 정확하고 관련성 있는 구체적인 답변을 효과적으로 생성할 수 있다.

프롬프트 공학을 코딩에 적용할 때의 장점은 자연어로 의도를 표현할 수 있어 코딩 입문자도 쉽게 접근할 수 있고, 수많은 프로그래밍 언어에 대한 장벽이 크게 낮아진 것을 수 있다. 또한 기존 코드를 수정하거나 새로운 코드를 작성할 때 생산성을 높일 수 있고, 언어모델이 제공하는 광범위한 지식을 활용할 수 있어 코드의 품질이 향상되었다. 하지만, 프롬프트를 잘 설계하기 위해서 프롬프트 공학에 대한 지식과 경험이 필요하기 때문에 프롬프트 공학에 대한 깊은 이해가 필요하고, 언어모델 출력 결과가 완벽하지 않기 때문에 필연적으로 전문 개발자의 검토와 수정이 필요하고 저작권을 비롯한 보안 및 윤리 문제가 풀어야 되는 숙제다.

프롬프트 공학을 코딩에 적용하는 절차는 전통적인 코딩 절차와 별반 다르지 않다. 첫째로 목표를 설정하고, 작성하려는 코드의 정확한 기능과 요구사항을 명시하여 코드가 어떤 입력을 받고, 어떤 출력을 내야 하는지 파악한다. 둘째로 목표를 자연어 프롬프트에 담아낸다.
가능한 상세하고 구체적인 프롬프트를 작성하고 사례, 제약조건 등도 포함한다.
셋째로 프롬프트를 대규모 언어모델에 입력한다. 언어모형이 프롬프트를 이해하고 관련 코드를 
생성하는 본 작업을 진행하고 필요한 경우 추가 프롬프트를 언어모형에 피드백을 제공한다.
넷째로 생성된 코드를 주의 깊게 검토하고 오류, 비효율성, 스타일 이슈 등을 반영하여 코드품질을 향상시킨다. 다섯째로 다양한 입력 값으로 코드를 실행하고 출력을 검증하고 발견된 오류는 디버깅하여 수정한다. 마지막으로 테스트 결과를 바탕으로 프롬프트를 개선할 점을 파악하고, 프롬프트를 수정하여 새로운 코드를 생성한 후 결과를 비교하는 과정을 반복한다.

![챗GPT 코딩 작업흐름](images/gpt_coding_workflow.jpg){#fig-gpt-coding-workflow}

챗GPT 코딩 구성요소는 프롬프트와 언어모형으로 구성되어 있다고 보면된다. 
자연어 프롬프트를 통해 생성하고자 하는 코드의 목적과 요구사항을 명시하여 언어모형에 전달하면 
언어모형은 프롬프트를 이해하고 관련 코드를 생성한다. 몇년전 영어가 가장 뜨거운 프로그래밍 언어라는 주장이 허언은 아닌 것이다.

{{< tweet user=karpathy id=1617979122625712128 >}}


## 챗GUI 인터페이스

`survey.db` 데이터베이스 SQL 쿼리를 개발자가 직접 작성하는 것을 지양하고 AI를 사용하여 SQL 쿼리를 제작한다. 현존하는 가장 성능이 높은 AI로 평가받는 OpenAI GPT-4 챗팅 인터페이스를 사용하여 SQL 쿼리를 제작한다.

::: {.content-visible when-format="html"}

::: {.panel-tabset}

### 프롬프트

``` bash
You are an expert in SQL. The following table definitions have been provided to you. Please convert my query into an appropriate SQL statement.

CREATE TABLE Person(
        ident    text,
        personal text,
        family   text
);
CREATE TABLE Site(
        name text,
        lat  real,
        long real
);
CREATE TABLE Visited(
        ident integer,
        site  text,
        dated text
);
CREATE TABLE Survey(
        taken   integer,
        person  text,
        quant   text,
        reading real
);

Let's write an SQL query to display the names of scientists on the screen.
```

### 출력결과

To write an SQL query that displays the names of scientists, we need to determine which table and column(s) contain the relevant information about the scientists. Based on the provided table definitions, it seems that the `Person` table holds the information about individuals, which likely includes scientists. The columns `personal` and `family` in the `Person` table seem to be the ones that store the names of individuals.

The query would be straightforward, as it involves selecting data from a single table without any joins or complex conditions. Here is the SQL statement:

```sql
SELECT personal, family
FROM Person;
```

This query will display the personal (given name) and family (surname) of each individual in the `Person` table. If you need just the full names combined or have other specific requirements, the query can be adjusted accordingly.

:::

:::

