
# 공개 과학과 호스팅 {#git-open}

::: callout-warning

"공개(open)"의 반대는 "폐쇄(closed)"가 아니다. "공개(open)"의 반대는 "망한(broken)" 것이다. 
- The opposite of "open" isn't "closed". The opposite of "open" is "broken".

:::


정보의 자유 공유는 과학에서 이상적일지 모르지만, 현실은 좀더 복잡하다. 현재, 보통 실무사례는 다음과 같다:

*   과학자가 데이터를 수집하고 학과에 가끔 백업되는 컴퓨터에 저장한다.
*   데이터를 분석하기 위해서 작은 프로그램을 작성하고 수정한다. (프로그램도 연구원의 로컬 노트북에 저장된다.)
*   적당한 분석 결과가 생성되자 마자, 작성해서 논문을 제출한다. 
    데이터를 논문에 포함할 수도 있다. (점점 많은 저널이 데이터를 요구한다.) 하지만, 아마도 프로그램 코드는 포함하지 않을 것이다.
*   시간이 흐른다.
*   저널에서는 연구원 분야의 익명으로된 소수의 사람들에게서 받아 검토(review)결과를 보낸다. 검토 결과를 충족하도록 논문을 수정한다. 
    수정하는 동안에 앞서 작성한 프로그램, 스크립트를 변경해서 다시 제출한다.
*   좀더 많은 시간이 흐른다.
*   종국에 논문이 출판된다. 
    논문에 데이터 온라인 사본 링크를 포함할 수도 있다. 
    하지만, 논문은 유료로 돈을 내야만 접근가능하다는 장벽(paywall)에 막혀있다:
    개인 혹은 기관 접근 권한을 가진 사람만이 논문을 읽을 수 있다.

하지만, 점점 더 많은 과학자들에게, 프로세스는 다음과 같다:

*   과학자가 수집한 데이터가 수집되는 즉시, [figshare](http://figshare.com/) 혹은 [Zenodo](http://zenodo.org)같은 공개 접근 저장소에 저장된다. 
    그리고 [디지털 객체 식별자(Digital Object Identifier, DOI)](https://en.wikipedia.org/wiki/Digital_object_identifier)가 부여된다.
    혹은 데이터를 이미 게시하고 [Dryad](http://datadryad.org/)에 저장한다.
*   과학자가 작업물을 보관할 저장소를 GitHub에 생성한다.
*   분석작업을 수행하면서, 스크립트의 변경사항을 (아마도 몇몇 산출 결과도 포함해서) 저장소에 푸쉬한다. 
    논문을 위한 저장소를 다목적으로 사용한다; 이 저장소가 다른 동료 과학자와 협업하는 허브가 된다.
*   논문 상태에 만족할 정도로 진행되면, 
    [arXiv](http://arxiv.org/) 혹은 다른 사전 출력 서비스에 게시하고, 다른 동료 과학자를 초대해서 피드백을 받는다.
*   피드백에 기초해서 저널에 논문을 마지막으로 제출하기 전 몇번의 수정사항을 게시할 수도 있다.
*   출판된 논문은 사전출판논문, 코드, 그리고 데이터 저장소의 링크를 포함한다. 
    그렇게 함으로써 다른 과학자가 본인 연구의 시작점으로 삼아서 연구를 쉽게 연결해서 수행할 수 있게 된다.

이러한 공개 연구 모형은 발견을 가속시킨다. 
연구 작업이 더 많이 공개될수록, 
[더 많이 인용되고 재사용된다(the more widely it is cited and re-used)](http://dx.doi.org/10.1371/journal.pone.0000308). 
하지만, 이런 방식으로 작업하고 연구하고자 하는 사람들은 실무에서 "공개(open)"가 정확하게 의미하는 바에 대해서 몇가지 결정을 내릴 필요가 있다.
공개 과학(Open Science)에 관한 다른 측면에 대해서 [이 책](https://link.springer.com/book/10.1007/978-3-319-00026-8)을 참고한다.

이것이 버젼 제어(version control)를 가르치는 (많은) 이유 중의 하나다.
버젼제어가 꾸준히 사용될 때,
컴퓨터 작업에 대한 공유가능한 전자연구노트로 활동함으로써 "방법"에 대한 질문에 답을 한다:
    

*   누가 언제 무엇을 했는지를 포함해서, 작업에 대한 개념적 단계가 문서화된다.
    모든 단계는 (커밋 ID)식별자로 도장이 찍힌다. 식별자는 의도와 목적을 갖는 중복되지 않고 유일하다.
*   정당성(rationale), 아이디어, 다른 지적 작업에 대한 문서화를 이것에서 파생된 변경사항과 묶을 수 있다.
*   중복되지 않고 유일하며 복구가능한 방식으로 컴퓨터 작업 결과물을 얻어서 연구에 사용할 것을 조회할 수 있다.
*   Git같은 분산된 버젼제어 시스템으로, 
    버젼제어 저장소는 영속성을 쉽게 얻을 수 있고, 전체 이력을 담아낼 수 있다.

::: callout-tip
### 코드를 인용가능하게 만들기

버젼제어 저장소에 올라온 모든 것(데이터, 코드, 논문 등)은 인용가능한 객체로 변환시킬 수 있다.
[lesson 12: 인용(Citation)]({{ page.root }}/12-citation/)에서 인용하는 방법에 대해서 학습하게 된다.

:::

::: callout-tip
### 내 작업을 어떻게 재현가능하게 만들 수 있을까?

연구실 동료중 한명에게 논문에 나온 내용과 웹으로만 
최근에 본인이 성취한 결과를 재현할 수 있는지 물어본다.
동료 결과물 중 하나에 대해서도 같은 작업을 수행해 본다.
그리고 나서, 일하고 있는 연구실에 나온 결과물에 대해서도
시도를 해본다.

:::

::: callout-tip
### 적절한 데이터 저장소를 찾는 방법?

2~3분정도 인터넷을 검색하고 앞에서 언급된 데이터 저장소를 조사해 본다:
[Figshare](https://figshare.com/), [Zenodo](https://zenodo.org),
[Dryad](https://datadryad.org/). 
전공분야에 따라, 본인 전공분야별로 잘 알려진 저장소가 도움이 될 수 있다.
[Nature에서 추천한 데이터 저장소](https://www.nature.com/sdata/data-policies/repositories)도 
유용할 수 있다.

주변 동료와 현재 작업에 사용하고 있는 데이터 저장소에 대해서 토론해 보고,
이유도 설명해 보자.

:::

## 협업 {#git-collab}

다음 단계로, 짝을 이룬다. 
한 사람이 "소유자"(연습을 시작하는데 사용될 GitHub 저장소 주인)가 되고, 
다른 사람이 "협력자"(소유자 저장소를 복제해서 변경을 하는 사람)가 된다.
목표는 협력자가 변경사항을 소유자 저장소에 추가하는 것이다.
말미에는 역할을 바꿔서 두 사람 모두 소유자와 협력자의 역할을 수행한다.

::: callout-tip
### 혼자 훈련하기

혼자 힘으로 이번 학습을 쭉 진행해 왔다면, 두번째 터미널을 열어서 계속 진행할 수 있다.> 
두번째 윈도우가 여러분의 협력자를 나타내고, 다른 컴퓨터에서 작업하고 있는 것으로 볼 수 있다.
GitHub 접근권한을 다른 사람에게 줄 필요가 없어졌다.
왜냐하면 두 '파트너' 모두 여러분이기 때문이다.

:::

소유자가 협력자에게 접근권한을 부여할 필요가 있다. 
GitHub에서 오른쪽에 'setting' 버튼을 클릭해서 협력자(`Collaborators`)를 선택하고, 
파트너 이름을 입력한다.

![GitHub에 협업자(Collaborators) 추가](images/git/github-add-collaborators.png)

소유자 저장소에 접근 권한이 부여되면, 
협력자(Collaborator)는 [https://github.com/notifications](https://github.com/notifications)으로 이동한다.
그곳에서 소유자 저장소의 접근을 받아들이면 된다.

다음으로 협력자(Collaborator)는 소유자 저장소 사본을 본인 컴퓨터로 내려받는다.
이런 작업을 "저장소 복제(cloning a repo)"라고 부른다.
소유자의 저장소를 본인 바탕화면(`Desktop`) 폴더에 클론하려면, 협력자는 다음 명령어를 입력한다:

``` bash
$ git clone https://github.com/vlad/planets.git ~/Desktop/vlad-planets
```


'vlad'를 소유자 사용자이름(저장소를 소유하고 있는 사람)으로 바꾼다.

![저장소 클론한 후 모습](images/git/github-collaboration.svg)

앞서 작업했던 것과 정확하게 동일한 방식으로, 
협력자는 이제 소유자의 저장소 클론에서 변경을 마음대로 할 수 있다:

``` bash
$ cd ~/Desktop/vlad-planets
$ nano pluto.txt
$ cat pluto.txt

It is so a planet!
```

``` bash
$ git add pluto.txt
$ git commit -m "Add notes about Pluto"

 1 file changed, 1 insertion(+)
 create mode 100644 pluto.txt
```


그리고 나서, 변경사항을 GitHub의 *소유자 저장소*로 푸쉬한다:

``` bash
$ git push origin master

Counting objects: 4, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 306 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/vlad/planets.git
   9272da5..29aba7c  master -> master
```


주목할 점은 `origin` 이라는 원격 저장소를 생성할 필요는 없다:
저장소를 복제(clone)할때 Git이 자동으로  `origin` 이름을 붙여준다. 
(수작업으로 원격 설정을 할 때, 앞에서 왜 `origin` 이름을 사용한 것이 현명한 선택인 이유다.)


이제 GitHub 웹사이트에서 소유자 저장소를 살펴본다(아마도 웹브라우져 다시 고치기를 수행할 필요가 있을 수 있다.)
협력자가 신규 커밋을 한 것을 확인할 수 있다.

소유자 로컬 컴퓨터로 GitHub 원본 저장소의 변경사항을 다운로드하려면, 
소유자는 다음과 같이 입력한다:

``` bash
$ git pull origin master

remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://github.com/vlad/planets
 * branch            master     -> FETCH_HEAD
Updating 9272da5..29aba7c
Fast-forward
 pluto.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 pluto.txt
```


이제 저장소 3개 (소유자 로컬 저장소, 협력자 로컬 저장소, GitHub의 소유자 저장소) 모두 동기화 되었다.

::: callout-tip
### 기본적인 협업 작업흐름

실무에서 협업하는 저장소의 가장 최신 버전을 갖도록 확인하고 확인하는 것이 좋다.
어떤 변경을 가하기 전에 `git pull` 명령어를 먼저 실행해야 한다.
기본적인 협업 작업흐름은 다음과 같다.

* `git pull origin master` 명령어로 본인 로컬 저장소를 최신상태로 갱신한다.
* 변경 작업을 수행하고 `git add` 명령어로 준비단계(staging area)로 보낸다.
* `git commit -m` 명령어로 변경사항을 커밋한다.
* GitHub에 `git push origin master` 명령어로 변경사항을 업로드한다.

상당한 변경사항을 포함한 단 한번의 커밋보다 작은 변화를 준 커밋을 많이 하는 것이 좋다:
작은 커밋이 가독성도 좋고 리뷰하기도 더 편하다.

:::

::: callout-tip
### 역할을 바꾸고 반복한다.

역할을 바꿔서 전체 과정을 반복한다.
:::


::: callout-tip
### 변경사항 리뷰

협력자에게 어떤 정보도 주지않고 소유자가 저장소에 커밋을 푸쉬했다.
협력자는 명령라인으로 무엇이 변경되었는지 어떻게 알 수 있을까요?

> **해답**
> 
> 명령라인에서 협력자는 로컬 저장소에 원격 저장소 변경사항을 
> ```git fetch origin master``` 명려어를 사용해서 가져올 수 있다.
> 하지만, 그 자체로 병합(merge)되는 것은 아니다.
> ```git diff master origin/master``` 명령어를 실행해서,
> 협력자는 터미널에 변경사항을 확인할 수 있다.
>
> GitHub에서도 협력자는 포크된 저장소로 가서 "This branch is 1 commit behind Our-Repository:master."
> 메시지를 볼 수 있다.
> `Compare` 아이콘과 링크가 걸려있다.  `Compare` 페이지에서 
> 협력자는 base fork를 본인 저장소로 변경하고 나서, "compare across forks" 위에 
> 링크를 클릭한다. 마지막으로 head fork를 주 저장소로 변경한다.
> 이 작업을 하게 되면 차이가 나는 모든 커밋을 볼 수 있게 된다.

:::

::: callout-tip
### GitHub에서 변경사항 주석(comment)달기

협력자는 소유자가 변경한 한 줄에 대해 질문을 가질 수 있고,
일부 제안사항도 있다.

GitHub으로 커밋 차이에 대해 주석을 다는 것도 가능하다.
파란색 주석 아이콘(comment icon)을 클릭하면 주석 윈도우(comment window)을 열 수 있다.

협력자는 GitHub 인터페이스를 사용해서 코멘트와 제안을 남길 수 있다.
:::

::: callout-tip
### 버전 이력, 백업, 그리고 버전 제어

일부 백업 소프트웨어는 파일 버전에 대한 이력을 기록하고 있다.
도한, 특정 버전을 복구하는 기능도 제공하고 있다.
이러한 기능이 버전 제어와 어떻게 다른가?

버전제어, Git, GitHub을 사용하는 좋은 점은 무엇인가?

:::


## 라이선싱 {#git-licensing}

### 소프트웨어 라이선스 {#git-license-sw}

소스코드, 원고, 다른 창의적 저작물을 갖는 저장소가 공개될 때,
저장소 기반 디렉토리에 `LICENSE` 혹은 `LICENSE.txt` 파일을 포함해서 콘텐츠가 어떤 라이선스로 이용가능한지를 명확히 기술해야된다.
이유는 소스코드가 창의적 저작물로서, 자동적으로 지적재산(따라서 저작권)보호에 대상에 부합되기 때문이다. 
자유로이 이용가능한 것으로 보여지거나, 명시적으로 광고되는 코드는 그런 보호를 유예하지 *않는다*. 
따라서, 라이선스 문장이 없는 코드를 (재)사용하는 누구나 스스로 위험에 처하게 된다. 
왜냐하면 소프트웨어 코드 저자가 항상 일방향으로 재사용을 불법화할 수 있기 때문이다.
즉, 저작권 소유자가 당신을 저작권법 위반으로 고소할 수 있다.


라이선스는 그렇지 않다면 보유하지 못할 권리를 다른 사람(라이선스 허여자, licensee)에게 부여함으로써 이 문제를 해결한다.
어떤 조건아래서 무슨 권리가 부여될지는 라이선스마다 다소 차이가 난다.
독점적 라이선스와 대조하여, [Open Source Initiative](http://opensource.org/)에서 공인된 
[오픈 라이선스(open licences)](http://opensource.org/licenses/alphabetical)는 최소한 다음에 나온 권리를 모두 부여한다. 
이런 권리를 [오픈 소스 정의(Open Source Definition)](http://opensource.org/osd)로 부른다.:

1. 소스코드는 제약없이 이용가능하고, 사용되고, 재배포될 수 있다.
   종합 배포의 일부로서도 포함된다.
2. 변형 혹은 다른 파생 저작물도 허락되고, 또한 재배포될 수 있다.
3. 이런 권리를 누가 받느냐의 질문이 차별의 조건이 되지 않는다.
   예를 들어 상업적 혹은 학술적처럼 노력 분야에 의해서가 아님도 포함된다.

특히, 지금까지 라이선스 몇개가 인기를 얻고 있는데, 
[choosealicense.com](https://choosealicense.com/) 웹사이트에서 본인 상황에 적합한 
일반적인 라이선스를 선택하는데 도움이 된다. 주요한 고려사항에는 다음이 포함된다:

* 특허권을 주장하고자 하는가?
* 파생 저작물을 배포하는데 다른 사람도 소스코드를 배포하도록 강제할 것인가?
* 라이선싱하는 콘텐트가 소스코드인가?
* 이왕이면 소스코드도 라이선스할 것인가?

적절한 라이선스를 가장 잘 선택하는 것이 상당히 많은 가능한 조합이 있어 주눅이 들 수도 있다. 
실무에서, 일부 라이선스만 지금까지 가장 인기가 있고, 다음이 그 범주에 포함된다:

* [GNU 일반공중 라이선스](http://opensource.org/licenses/GPL-3.0)
  (GPL),
* [MIT 라이선스](http://opensource.org/licenses/MIT),
* [BSD 라이선스](http://opensource.org/licenses/BSD-2-Clause),
* [아파치 라이선스, 버젼 2.0](http://opensource.org/licenses/Apache-2.0).

GPL은 다른 대부분의 공개소스 라이선스와 다른데, 
[전염성이 있는(infective)](http://swcarpentry.github.io/git-novice/reference.html#infective) 특징이 있다: 코드의 수정된 버젼을 배포하는 누구나 혹은 GPL 코드를 포함한 어느 것이든지, *자신의* 코드도 동일하게 자유로이 공개가능하게 만들어야 한다.

흔히 사용되는 라이선서를 선택하는 것이 기여자나 사용자의 삶을 편하게 한다.
왜냐하면, 기여자나 사용자 모두 해당 라이선스에 친숙해서 사용할 때 상당한 양의 전문용어를 
꼼꼼히 살펴볼 필요가 없기 때문이다.

[Open Source Initiative](https://opensource.org/licenses)와 [Free Software Foundation](https://www.gnu.org/licenses/license-list.html) 모두 
좋은 선택이 될 수 있는 라이선스 목록을 유지관리하고 있다.

코드를 작성하는 과학자 관점에서 라이선싱과 라이선싱 선택지에 대한 전반적인 정보를 
[이 기사][software-licensing]를 통해서 살펴볼 수 있다.

결국 가장 중요한 것은 라이선스가 무엇인지에 대해 분명한 문장이 있는지와 라이선스가 [OSI](http://opensource.org)와 [FSF](https://www.gnu.org/licenses/license-list.html)에서 승인되고 이미 검증된 것인지 여부다.
또한, 저장소에 공개된 것이 아닐지라도, 
처음부터 최선으로 라이선스를 선택해야 된다.
결정을 미루는 것은 나중에 더 복잡하게 된다.
왜냐하면, 매번 새로운 협력자가 기여하기 시작하면, 협력자도 저작권을 갖게된다.
따라서, 라이선스를 고르자 마자, 승인을 득해야할 필요가 있기 때문이다.

::: callout-tip
### 본인이 오픈 라이선스를 사용할 수 있나요?

여러분이 작성하고 있는 소프트웨어에 오픈소스 소프트웨어 라이선스를 적용할 수 있는지 알아본다.
여러분이 라이선스 적용을 일방적으로 할 수 있는가? 
혹은 여러분의 기관이나 조직의 다른 사람에게서 허락이 필요한가? 
만약 그렇다면 누굴까?

:::

::: callout-tip
### 본인은 어떤 라이선스를 이미 승인했나요?

(금번 워크샵을 포함해서) 매일 사용하는 대다수 소프트웨어는 오픈-소스 소프트웨어로 
출시되었다. 
아래 목록 혹은 본인이 직접 고른 GitHub 사이트에서 프로젝트를 하나 고른다.
라이선스를 찾아(보통 `LICENSE` 혹은 `COPYING` 이름이 붙은 파일)보고, 
소프트웨어 사용을 어떻게 제약하는지 살펴보자.
이번 세션에서 논의된 라이선스 중 하나인가? 
차이점은 어떻게 나는가?

- [Git](https://github.com/git/git), 소스코드 관리 도구
- [CPython](https://github.com/python/cpython), 파이썬 언어 구현 
- [Jupyter](https://github.com/jupyter), 웹기반 파이썬 노트북 프로젝트
- [EtherPad](https://github.com/ether/etherpad-lite), 실시간 협업 편집기

:::

[software-licensing]: https://doi.org/10.1371/journal.pcbi.1002598

### 콘텐츠 라이선스 {#git-licensing-contents}

만약 저장소 콘텐츠가 소프트웨어가 아닌 데이터, 창의적 저작물(매뉴얼, 기술 보고서, 원고) 같은 연구제품이 포함되면,
소프트웨어를 위해 설계된 라이선스 대부분은 적합하지는 *못하다*.

* **데이터:** 대부분 국가사법권에서 데이터 유형 대부분은 자연에 대한 사실로 간주된다. 
  그럼으로, 저작권 보호를 받을 자격이 없다.(단, 아마도 사진과 의료영상정보 등은 예외)
  따라서, 저작자 표시로 사회적 혹은 학자적 기대치를 알리려고, 저작권을 정의로 주장하는 방식으로 라이선스를 사용하는 것은 단지 법적으로 혼탁한 상황만 조장할 뿐이다. 
  [크리에이티브 커먼즈 제로(Creative Commons Zero, CC0)](https://creativecommons.org/publicdomain/zero/1.0/) 처럼 공중도메인 권리포기를 지지하는 법적 표시를 분명히 하는 것이 더 낫다. [Dryad](http://datadryad.org) 데이터 저장소는 사실 이를 요구하고 있다.

* **창의적 저작물(Creative works):** 매뉴얼, 보고서, 원고, 기타 창의적 저작물은 지적재산 보호 대상이 된다. 따라서 소프트웨어와 마찬가지로 자동으로 저작권으로 보호된다. [크리에이티브 커먼즈(Creative Commons)](http://creativecommons.org/) 조직이 기본 제약사항 4개를 조합해서 [라이선스 집합](http://creativecommons.org/licenses/)을 마련했다:

    *   저작자 표시(Attribution): 파생 저작물에 대해서 최초 저작자의 이름, 출처 등의 정보를 반드시 표시해야 한다.
    *   변경 금지(No Derivative): 저작물을 복사할 수도 있으나 저작물을 변경 혹은 저작물을 이용하여 2차적 저작물로 제작을 금한다.
    *   동일조건변경허락(Share Alike): 2차적 저작물을 제작할 수 있으나, 2차적 저작물은 원래 저작물과 동일한 라이선스를 적용한다.
    *   비영리(Noncommercial): 저작물을 영리 목적으로 사용할 수 없음. 영리 목적을 위해서는 별도의 계약이 필요하다.  
  

출처표시 ([CC-BY](http://creativecommons.org/licenses/by/4.0/))와 동일조건변경허락([CC-BY-SA](http://creativecommons.org/licenses/by-sa/4.0/)) 라이선스만이 "[오픈](http://opendefinition.org/) 라이선스"로 간주된다.

[소프트웨어 카펜트리](http://software-carpentry.org/license.html)는 가능하면 폭넓게 재사용될 수 있도록 수업자료에 대해서는 CC-BY, 코드에는 MIT 라이선스를 사용한다. 
다시 한번, 가장 중요한 것은 프로젝트 루트 디렉토리에 있는 `LICENSE` 파일에 라이선스가 무엇인지 분명하게 언급한다.
본인 프로젝트를 참조하는 방법을 기술하는데 `CITATION` 혹은 `CITATION.txt` 파일을 포함할 수도 있다. 소프트웨어 카펜트리 사례는 다음과 같다:


``` bash
To reference Software Carpentry in publications, please cite both of the following:

Greg Wilson: "Software Carpentry: Lessons Learned". arXiv:1307.5448, July 2013.

@online{wilson-software-carpentry-2013,
  author      = {Greg Wilson},
  title       = {Software Carpentry: Lessons Learned},
  version     = {1},
  date        = {2013-07-20},
  eprinttype  = {arxiv},
  eprint      = {1307.5448}
}
```


## 호스팅 {#git-hosting}

저작물이나 작업을 공개하고자 하는 그룹에서 가지는 두번째 큰 질문은 코드와 데이터를 어디에 호스팅할지 정하는 것이다. 
방법중 하나는 연구실, 학과, 혹은 대학이 서버를 제공하여 계정관리와 백업 등등을 관리하는 것이다. 
주된 장점은 누가 무엇을 소유하는지 명확하다. 
특히 민감한 정보(예를 들어, 사람에 대한 실험정보 혹은 특허 출원에 사용될 수도 있는 정보)가 있다면 중요하다. 
큰 단점은 서비스 제공 비용과 수명이다: 
데이터를 수집하는데 10년을 보낸 과학자가 지금부터 10년 후에도 여전히 이용가능하기를 원하지만, 학교 인프라를 지원하는 대부분의 연구기금의 수명이 턱없이 짧다.

또다른 선택지는 도메인을 구입하고 호스팅하는데 ISP(인터넷 서비스 제공자, Internet service provider)에 비용을 지불한다. 
이 접근법은 개인이나 그룹에게 좀더 많은 제어권을 주고 학교나 기관을 바꿀 때 생기는 문제도 비켜갈 수 있다. 
하지만, 위나 아래 선택지보다 초기 설정하는데 더 많은 시간과 노력이 요구된다.

세번째 선택지는 [GitHub](http://github.com), [BitBucket](http://bitbucket.org), 혹은
[SourceForge](http://sourceforge.net) 같은 공개 호스팅 서비스를 채용하는 것이다. 
웹 인터페이스를 통해서 저장소 코드를 생성하고, 보고, 편집할 수 있게 한다.
이러한 서비스는 이슈추적, 위키 페이지, 이메일 통보, 코드 리뷰를 포함한 커뮤니케이션과 프로젝트 관리 도구도 제공한다. 
이러한 서비스는 규모의 경제와 네트워크 효과로 모두 이익을 볼 수 있다: 즉, 동일한 표준을 갖는 작은 많은 서비스를 실행하는 것보다 큰 서비스 하나를 실행하는 것이 더 쉽다.
또한, 사람들이 협업하기도 더 쉽다.
대중적인 서비스를 사용하면 이미 동일한 서비스를 사용하는 커뮤니티와 본인 프로젝트를 연결하는데 도움이 된다.

예로서, 소프트웨어 카펜트리는 [GitHub]({{ swc_github }})에 있어서, 
[해당 페이지에 대한 소스코드]({{page.root}}/_episodes/13-hosting.md)를 찾아볼 수 있다. 
GitHub 계정을 갖는 누구나 해당 페이지에 변경사항을 제안할 수 있다.

GitHub 저장소에서 [Zenodo에 릴리스(release)를 연결하면](https://guides.github.com/activities/citable-code/)
DOI를 부여할 수도 있다.
예를 들어, [`10.5281/zenodo.57467`](https://zenodo.org/record/57467)이 "Git 소개"에 대해 주조된 DOI다.

규모가 크고 잘 정립된 서비스를 사용하는 것이 빠르게 강력한 도구의 장점을 흡수하는데 도움을 줄 수도 있다.
지속적 통합(Continuous integration, CI)이 그런 도구 중 하나로 자동으로 소프트웨어 빌드를 돌리고 코드가 커밋되거나 풀요청이 제출될 때마다 실행된다. 
온라인 호스팅 서비스와 CI를 직접 통합이 의미하는 바는, 어떤 풀요청에도 해당 정보가 존재해서 코드 완결성과 품질 표준을 유지하는데 도움을 준다.
여전히 CI가 자가 구축한 호스팅 상황에도 이용가능하지만,
온라인 서비스 사용과 연계되면 초기설정과 유지보수 업무를 줄일 수 있다. 
더욱이, 이러한 도구가 오픈소스 프로젝트에 무료로 제공되기도 한다.
사설 저장소에 대해서만 비용 일부를 지불하고 이용가능하다.

::: callout-tip
### 제도적 장벽 (Institutional Barriers)

공유가 과학에는 이상적이지만,
많은 기관에서 공유에 제약을 가한다.
예를 들어 잠재적으로 특허가능한 지적재산을 보호하는데 말이다.
만약 여러분이 그런 제약과 마주한다면,
특정 프로젝트 혹은 도메인에 예외를 요청하거나,
제도 혁파를 통해서 더 공개된 과학을 지지하도록 좀더 
앞서 나가는데 근본적인 동기에 관해 질의하는 것이 더 생산적일 수 있다.

:::

::: callout-tip
### 본인 작업을 공개할 수 있을까?

본인 작업을 공개 저장소에 공개할 수 있는지 알아보자.
공개 작업을 일방적으로 할 수 있을까?
혹은 속한 조직의 누군가로부터 허락이 필요한가?
만약 그렇다면 조직의 누굴까?
:::

::: callout-tip
### 본인 작업을 어디에 공개할 수 있을까?

본인 논문, 데이터, 소프트웨어를 공유하려면 이용가능한 저장소가 
소속기관에 갖추어져 있는가?
소속기관 저장소는 [arXiV](https://arxiv.org/), [figshare](https://figshare.com/), [GitHub](https://github.com/) or [GitLab](https://about.gitlab.com/)와 
같은 데이터 저장소 서비스와 비교하여 어떤 차이점이 있는가?

:::


  


